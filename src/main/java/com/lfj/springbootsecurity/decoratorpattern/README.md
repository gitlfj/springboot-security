  
  看类图，Component 是一个接口或者是抽象类，就是定义我们最核心的对象，也就是最原始的对象，比
如上面的成绩单，记住在装饰模式中，必然有一个被提取出来最核心、最原始、最基本的接口或抽象类，就是 Component。

  ConcreteComponent 这个事最核心、最原始、最基本的接口或抽象类的实现，你要装饰的就是这个东东。
  
  Decorator 一般是一个抽象类，做什么用呢？实现接口或者抽象方法，它里面可不一定有抽象的方法呀，
在它的属性里必然有一个 private 变量指向 Component。

  ConcreteDecoratorA 和 ConcreteDecoratorB 是两个具体的装饰类，你要把你最核心的、最原始的、最
基本的东西装饰城啥东西，上面的例子就是把一个比较平庸的成绩单装饰成家长认可的成绩单。

  装饰模式是对继承的有力补充，你要知道继承可不是万能的，继承可以解决实际的问题，但是在项目
中你要考虑诸如易维护、易扩展、易复用等，而且在一些情况下（比如上面那个成绩单例子）你要是用继
承就会增加很多了类，而且灵活性非常的差，那当然维护也不容易了，也就是说装饰模式可以替代继承，
解决我们类膨胀的问题，你要知道继承是静态的给类增加功能，而装饰模式则是动态的给增加功能，你看
上面的那个例子，我不想要 SortDecorator 这层的封装也很简单呀，直接在 Father 中去掉就可以了，如果
你用继承就必须修改程序。

  装饰模式还有一个非常好的优点，扩展性非常好，在一个项目中，你会有非常多因素考虑不到，特别
是业务的变更，时不时的冒出一个需求，特别是提出一个令项目大量延迟的需求时候，那种心情是…，真
想骂娘！装饰模式可以给我们很好的帮助，通过装饰模式重新封装一个类，而不是通过继承来完成，简单
点说，三个继承关系 Father,Son,GrandSon 三个类，我要再 Son 类上增强一些功能怎么办？我想你会坚决
的顶回去！不允许，对了，为什么呢？你增强的功能是修改 Son 类中的方法吗？增加方法吗 ？对 GrandSon
的影响哪？特别是 GrandSon 有多个的情况，你怎么办？这个评估的工作量就是够你受的，所以这个是不允
许的，那还是要解决问题的呀，怎么办？通过建立 SonDecorator 类来修饰 Son，等于说是创建了一个新的
类，这个对原有程序没有变更，通过扩充很好的完成了这次变更。